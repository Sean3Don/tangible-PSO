function obj = Iterate(obj)
persistent h1
persistent h2
persistent h3

% propagate step
for k = 1:obj.ParticlesCount
    x = obj.Particle(k).Agent.State;
    if (obj.Particle(k).Agent.CurrentIterationStep == 1)
        y = obj.Particle(k).Agent.getNewRandomState;
    else
        a = 0.5;
        b = 0.5;
        y = a*obj.Particle(k).BestState + ...
            b*obj.GlobalBestState;
    end
    u = obj.Particle(k).Agent.InverseKinematicsFcn(x, y);
    obj.Particle(k).Agent.UpdateState(u);
    if k == 1
        h1 = obj.Particle(k).Agent.PlotState(obj.Particle(k).Agent.State,'.k');
    end
end

% evaluate fitness for each particle
for k = 1:obj.ParticlesCount
    f = ...
        obj.CostFcn(obj.Particle(k).Agent.State,...
        obj.Goal.State);
    
    % check if it's particles' best
    if isempty(obj.Particle(k).Fitness)
        obj.Particle(k).Fitness = f;
    elseif (f < obj.Particle(k).Fitness)
        obj.Particle(k).BestState = ...
            obj.Particle(k).Agent.State;
        if k == 1
            delete(h1);
            if ~isempty(h2)
                delete(h2)
            end
            h2 = obj.Particle(k).Agent.PlotState(obj.Particle(k).BestState,'.b');
        end
        % and while we're at it, check if it's the global best
        if isempty(obj.GlobalFitness)
            obj.GlobalFitness = f;
        elseif (f < obj.GlobalFitness)
            obj.GlobalBestState = ...
                obj.Particle(k).Agent.State;
        end
    end
    
    obj.Particle(k).Fitness = f;
    
end

if ~isempty(h3)
    clear(h3(:))
end
h3 = obj.Particle(k).Agent.PlotState(obj.GlobalBestState,'.r');

end